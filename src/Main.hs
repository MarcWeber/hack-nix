{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS -cpp #-}
module Main where
import Codec.Compression.GZip(decompress)
import Codec.Archive.Tar as T


import Control.Monad.Reader.Class
import Control.Concurrent
import Data.Function
import Text.PrettyPrint
import qualified Data.Map as M
-- import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString.Lazy.Char8 as BL
-- import Distribution.Simple.Utils (findPackageDesc)
import Config
import Control.Exception
import Nix
import NixLanguage
import Index
import Data.Maybe
import Control.Monad
import Control.Monad.Trans
import System.Exit
import System.Directory
import System.Environment
-- import Network.URI
import Data.List
import Utils
import Patching
import BuildEnvs
-- import System.Process
import System.IO
import ProcessPool

#include "interlude.h"
import Interlude

-- writeConfig Map file = writeFile file $ lines $ mapWithKey

-- [>minimal Config 
-- parseConfig :: String -> Map
-- parseConfig =
--   let split s = let  (a,_:set) (break ( == '=') in (a,set)
--   in fromList . map split . lines

  
runWithConfig :: FilePath -> String -> [String] -> IO ()
runWithConfig tmpDir cfg args =  do
  cfg' <- liftM parseConfig $ readFile cfg
  print "config is"
  print cfg'
  withConfig cfg' $ do
    case args of
      [] -> updateHackageIndexFile tmpDir
      ["--unpack", fullName] -> unpackPackage fullName
      ["--create-patch", fullName] -> createPatch fullName
      ["--patch-workflow", fullName] -> patchWorkflow fullName (updateHackageIndexFile tmpDir)
      ["--to-nix"] -> packageToNix True >> return ()
      ["--write-hack-nix-cabal-config"] -> writeHackNixCabalConfig
      ("--build-env":args') -> buildEnv "default" args' -- assume default
      ("--build-env-name": name: args') -> buildEnv name args'
      ["--dump-hackage-db"] -> dumpHackageDB
      _ -> liftIO $ help >> exitWith (ExitFailure 1)

dumpHackageDB :: ConfigR ()
dumpHackageDB = do
    cfg <- ask
    liftIO $ do
      (hackageIndex', _) <- downloadCached (hackageIndex cfg) False
      dumpIndex =<< BL.readFile hackageIndex'

updateHackageIndexFile :: FilePath -> ConfigR ()
updateHackageIndexFile tmpDir = do
    cfg <- ask
    (hackageIndex', _) <- liftIO $ downloadCached (hackageIndex cfg) False
    liftIO $ putStrLn $ "hackage index is " ++ hackageIndex'
    pd <- asks patchDirectory

    indexContents <- liftIO $ BL.readFile hackageIndex'

    (sortedResults :: MVar (M.Map NixType NixType)) <- liftIO $ newMVar M.empty
    dummy <- liftIO $ runConcurrently (maxConc cfg)
                forkIO printProgress
                [readIndexTask cfg indexContents sortedResults tmpDir]

    -- wait for processes
    res <- liftIO $ takeMVar dummy
    let failures = [l | Left l <- res ]
    when ((not . null) failures) $ error $ show failures

    (attrs::[NixType])<- liftIO $ liftM M.elems $ takeMVar sortedResults

    tp <- asks targetPackages
    let comments = case tp of
          TPAll -> ["# TPAll = all packages"]
          TPCustom pl comment -> ["/* TPCustom " ++ show pl,
                                  comment,
                                  "*/"]
          TPMostRecentPreferred pl comment -> ["/* TPMostRecentPreferred " ++ show pl,
                                  comment,
                                  "*/"]
    let result = unlines $ ["### This file was generated by hack-nix automatically",
                            "# contens are determined by the hackage index and a set of patches"
                           ]
                           ++ comments
                           ++ ["["]
                           ++ (map (renderStyle style . toDoc) attrs)
                           ++ ["]"]

    liftIO $ do
      -- STDOUT 
      -- putStrLn result
      case targetFile cfg of 
        Just f -> writeFile f result
        Nothing -> return ()

main :: IO ()
main = (flip finally) saveNixCache $ do
  hSetBuffering stdin NoBuffering -- required because getChar is used to read y only
  loadNixCache
  dcp <- defaultConfigPath
  tmpDir <- newTempdir "hack-nix"
  args <- getArgs
  case args of
    ["--write-config"] -> writeSampleConfig dcp
    ["--write-config", cfg] -> writeSampleConfig cfg
    ["--print-format-info"] -> putStrLn $ formatInfo
    ["-h"] -> help
    ["--help"] -> help
    ("--config":cfg:args') -> do runWithConfig tmpDir cfg args'
    args' -> do
      de <- doesFileExist dcp
      case de of
        True -> runWithConfig tmpDir dcp args'
        False -> do  putStrLn $ "sample config does not exist, writing it to " ++ dcp
                     putStrLn "adjust it to your needs and rerun .."
                     writeSampleConfig dcp
                     putStrLn "done, also see --help"
                     exitWith (ExitFailure 1)

help :: IO ()
help = do
    dcp <- defaultConfigPath
    hSetEncoding stdout utf8
    progName <- getProgName
    putStrLn $ unlines $ map ("  " ++ ) $
          [ progName ++ ": get index from hackage making its contents readable by nix"
          , ""
          , ""
          , progName ++ " [cfg] dest         : create nix expressions and put them into dest"
          , ""
          , progName ++ "--print-format-info : prints format info about config"
          , progName ++ "--write-config [cfg]: writes an initial config file"
          , "default config path is: " ++ dcp
          , ""
          , "  writing patches: "
          , "  ================ "
          , "--unpack           full-name : unpacks source into working directory"
          , "--create-patch     full-name : create patch in target destination (haskell-nix-overlay)"
          , "all:"
          , "--patch-workflow   full-name : unpack, apply patch, start $SHELL, create patch, run git add and git commit"
          , "--to-nix           convert .cabal file in current directory into .nix format, put it into .dist/full-name.nix"
          , "                   so that you can import it easily and append it to the list of hackage packages"
          , "                   also run ./setup dist to create current dist file"
          , ""
          , "  creating environments to build cabal package "
          , "  ============================================ "
          , " --write-hack-nix-cabal-config : Writes a .hack-nix-cabal-config sample file"
          , "                                containing all variations of flags"
          , " --build-env  [nix-env options]         : build default env"
          , " --build-env-name name [nix-env options]: build env named name"
          , ""
          , "  querying  hackgae db dump (cause I don't trust the web interface ..)"
          , "  ========================================"
          , " --dump-hackage-db"
          ]

